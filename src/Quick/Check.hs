module Quick.Check
  ( quickCheck
  , quickCheckParallel
  , quickCheckAt
  , quickCheckParallelAt
  , QuickCheck (..)
  ) where

import Data.Functor ((<&>))
import Data.Foldable (toList)
import Check
import Space.Random
import Types

-- 'quickCheck' is a driver to test an individual pure property and show the
-- result

-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
{-# INLINE quickCheck #-}
quickCheck :: Natural
           -> Test assertion specimen result
           -> Domain space specimen
           -> IO (QuickCheck space specimen result assertion)
quickCheck n test domain = newSeedIO <&> quickCheckAt n domain test

-- | First number is the amount of parallelism, second is the number of random
-- samples to check.
{-# INLINE quickCheckParallel #-}
quickCheckParallel :: Natural
                   -> Natural
                   -> Test assertion specimen result
                   -> Domain space specimen
                   -> IO (QuickCheck space specimen result assertion)
quickCheckParallel m n test domain = newSeedIO <&> quickCheckParallelAt m n domain test

{-# INLINE quickCheckAt #-}
quickCheckAt :: Natural
             -> Domain space specimen
             -> Test assertion specimen result
             -> Seed
             -> QuickCheck space specimen result assertion
quickCheckAt n domain test seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkSequential (randomPoints (n' - 1) seed) domain test else Nothing)
  where
    !n' = clampToWord32 tag n
    tag = "quickCheckSequential"

{-# INLINE quickCheckParallelAt #-}
quickCheckParallelAt :: Natural
                     -> Natural
                     -> Domain space specimen
                     -> Test assertion specimen result
                     -> Seed
                     -> QuickCheck space specimen result assertion
quickCheckParallelAt m n domain test seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkParallel m' (randomPoints (n' - 1) seed) domain test else Nothing)
  where
    -- Want to crash early so we force these
    !m' = clampToWord32 tag m
    !n' = clampToWord32 tag n
    tag = "quickCheckParallel"

-- | A type for the result of a 'quickCheck', mainly defined for its Show
-- instance.
data QuickCheck space specimen result assertion where
  Passed :: Natural -> Seed -> QuickCheck space specimen result assertion
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space specimen result assertion -> QuickCheck space specimen result assertion

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
--
-- Doesn't show that much detail about a failure.
instance (Show space, Show specimen, Show result, Show assertion) => Show (QuickCheck space specimen result assertion) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  -- TODO show more.
  show (Failed _ seed cexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed, "\n"
    , "Random seed:     ", showSeedHex (randomSeed cexample), "\n"
    , "Search point:    ", show (searchPoint cexample), "\n"
    , "Generated value: ", show (generatedValue cexample), "\n"
    , "Test result:     ", show (testResult cexample), "\n"
    , "Refuted:         ", show (toList (refutations cexample))
    ]
