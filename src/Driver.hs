module Driver
  ( Counterexample (..)
  , checkSequential
  , checkSequentialAll
  , checkParallel
  , checkParallelAll

  -- * Repl utils
  , quickCheck
  , quickCheckParallel
  , quickCheckAt
  , quickCheckParallelAt
  , QuickCheck (..)
  ) where

import Data.List.NonEmpty (NonEmpty, nonEmpty)
import Data.Text (Text)
import qualified Data.Text as T (unpack)
import Data.Functor ((<&>))
import Property
import Space.Random
import Space.Search
import Types

-- 'quickCheck' is a driver to test an individual pure property and show the
-- result
--
-- TODO
-- - an IO test driver which will show the srcloc of the failing property and
--   parameter and random seed which caused it to fail; better yet, the
--   particular space at which the minimal case was found. If we can show and
--   read and write the space then it's more useful; just reconstruct the
--   space, take the seed at that run, and you're good to go (no need to re
--   run the whole search).

{-# INLINE quickCheck #-}
-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
quickCheck :: t -> Natural -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheck t n prop = newSeedIO <&> \seed -> quickCheckAt seed t n prop

{-# INLINE quickCheckParallel #-}
quickCheckParallel :: t -> Natural -> Natural -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheckParallel t m n prop = newSeedIO <&> \seed -> quickCheckParallelAt seed t m n prop

{-# INLINE quickCheckAt #-}
quickCheckAt :: Seed -> t -> Natural -> Property state space dynamic result refutation t -> QuickCheck space dynamic refutation
quickCheckAt seed t n prop = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkSequential t (randomPoints (n-1) seed) prop else Nothing)

{-# INLINE quickCheckParallelAt #-}
quickCheckParallelAt :: Seed -> t -> Natural -> Natural -> Property state space dynamic result refutation t -> QuickCheck space dynamic refutation
quickCheckParallelAt seed t m n prop = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkParallel m t (randomPoints (n-1) seed) prop else Nothing)

-- | A type for the result of a 'quickCheck', mainly defined for its Show
-- instance.
data QuickCheck space dynamic refutation where
  Passed :: Natural -> Seed -> QuickCheck space dynamic refutation
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space dynamic refutation -> QuickCheck space dynamic refutation

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
instance Show (QuickCheck space dynamic refutation) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  show (Failed _ seed counterexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed, "\n"
    , T.unpack (prettyCounterexample counterexample)
    ]

-- | A counterexample produced by a property test. It gives the random seed and
-- search space, and also the value that was produced by the generator at this
-- point (even though it can be reproduced). It also has the non-empty set of
-- refutations, corresponding to the expectations which failed at this point.
data Counterexample space dynamic refutation = Counterexample
  { randomSeed :: Seed
  , searchPoint :: space
  , dynamicPart :: dynamic
  , refutations :: NonEmpty refutation
  }

-- TODO
prettyCounterexample :: Counterexample space dynamic refutation -> Text
prettyCounterexample _ = mempty

{-# INLINE checkSequentialAll #-}
-- | Check the property at each of these seeds, giving all counterexamples.
checkSequentialAll :: t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkSequentialAll t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequentialAll
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkSequential #-}
-- | Check the property at each of these seeds, stopping at the first
-- counterexample.
checkSequential :: t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkSequential t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequential
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallel #-}
-- | Same as 'checkSequentialAll' but will check a given number in parallel (the
-- Natural number parameter) and every seed will be checked.
checkParallelAll :: Natural -> t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkParallelAll n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallelAll
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallelAll #-}
-- | 'checkParallel' but stop at the first counterexample.
checkParallel :: Natural -> t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkParallel n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallel
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

-- | Convert a search result into a counterexample.
{-# INLINE toCounterexample #-}
toCounterexample :: (Seed, (state, space, (dynamic, NonEmpty (Refutation refutation)))) -> Counterexample space dynamic refutation
toCounterexample (seed, (_, space, (dynamic, refutations))) = Counterexample
  { randomSeed = seed
  , searchPoint = space
  , dynamicPart = dynamic
  , refutations = fmap getRefutation refutations
  }

-- | Used to define a property test search.
{-# INLINE searchPredicate #-}
searchPredicate :: forall space dynamic result refutation t .
                   Gen space dynamic
                -> Test dynamic result refutation t
                -> t
                -> (Seed -> space -> Maybe (dynamic, NonEmpty (Refutation refutation)))
searchPredicate gen test t = \seed space ->
  -- It's important that this inlines well. Could it be improved?
  let dynamic = sampleAt seed space gen
      result = runSubject (subject test) t dynamic
      refutations :: [Refutation refutation]
      refutations = runConjunction (checkExpectation t dynamic result) (expectations test)
   in (,) dynamic <$> nonEmpty refutations

-- | Defined for use in runConjunction; choice of list is for its semigroup
-- instance.
{-# INLINE checkExpectation #-}
checkExpectation :: t -> dynamic -> result -> Expectation refutation dynamic result t -> [Refutation refutation]
checkExpectation t d r (Expectation refutation v) = case runVerification v t d r of
  True -> []
  False -> [refutation]
