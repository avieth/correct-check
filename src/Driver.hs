module Driver
  ( Counterexample (..)
  , checkSequential
  , checkSequentialAll
  , checkParallel
  , checkParallelAll

  -- * Repl utils
  , quickCheck
  , quickCheckParallel
  , quickCheckAt
  , quickCheckParallelAt
  , QuickCheck (..)

  -- * Low-level
  , searchPredicate
  ) where

import Data.List.NonEmpty (NonEmpty, nonEmpty)
import Data.Text (Text)
import qualified Data.Text as T (unpack)
import Data.Functor ((<&>))
import Data.Word (Word32)
import Property
import Space.Random
import Space.Search
import Types

-- 'quickCheck' is a driver to test an individual pure property and show the
-- result

-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
{-# INLINE quickCheck #-}
quickCheck :: Natural -> t -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheck n t prop = newSeedIO <&> quickCheckAt n t prop

{-# INLINE quickCheckParallel #-}
quickCheckParallel :: Natural -> Natural -> t -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheckParallel m n t prop = newSeedIO <&> quickCheckParallelAt m n t prop

{-# INLINE quickCheckAt #-}
quickCheckAt :: Natural
             -> t
             -> Property state space dynamic result refutation t
             -> Seed
             -> QuickCheck space dynamic refutation
quickCheckAt n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkSequential t (randomPoints (n' - 1) seed) prop else Nothing)
  where
    !n' = clampToWord32 tag n
    tag = "quickCheckSequential"

{-# INLINE quickCheckParallelAt #-}
quickCheckParallelAt :: Natural
                     -> Natural
                     -> t
                     -> Property state space dynamic result refutation t
                     -> Seed
                     -> QuickCheck space dynamic refutation
quickCheckParallelAt m n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkParallel m' t (randomPoints (n' - 1) seed) prop else Nothing)
  where
    -- Want to crash early so we force these
    !m' = clampToWord32 tag m
    !n' = clampToWord32 tag n
    tag = "quickCheckParallel"

-- | A type for the result of a 'quickCheck', mainly defined for its Show
-- instance.
data QuickCheck space dynamic refutation where
  Passed :: Natural -> Seed -> QuickCheck space dynamic refutation
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space dynamic refutation -> QuickCheck space dynamic refutation

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
instance Show (QuickCheck space dynamic refutation) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  show (Failed _ seed counterexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed, "\n"
    , T.unpack (prettyCounterexample counterexample)
    ]

-- | A counterexample produced by a property test. It gives the random seed and
-- search space, and also the value that was produced by the generator at this
-- point (even though it can be reproduced). It also has the non-empty set of
-- refutations, corresponding to the expectations which failed at this point.
data Counterexample space dynamic refutation = Counterexample
  { randomSeed :: Seed
  , searchPoint :: space
  , dynamicPart :: dynamic
  , refutations :: NonEmpty refutation
  }

-- TODO
instance Show (Counterexample space dynamic refutation) where
  show = const "Counterexample"

-- TODO
prettyCounterexample :: Counterexample space dynamic refutation -> Text
prettyCounterexample _ = mempty

{-# INLINE checkSequentialAll #-}
-- | Check the property at each of these seeds, giving all counterexamples.
checkSequentialAll :: t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkSequentialAll t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequentialAll
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkSequential #-}
-- | Check the property at each of these seeds, stopping at the first
-- counterexample.
checkSequential :: t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkSequential t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequential
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallel #-}
-- | Same as 'checkSequentialAll' but will check a given number in parallel (the
-- Word32 parameter) and every seed will be checked.
checkParallelAll :: Word32 -> t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkParallelAll n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallelAll
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallelAll #-}
-- | 'checkParallel' but stop at the first counterexample.
checkParallel :: Word32 -> t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkParallel n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallel
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

-- | Convert a search result into a counterexample.
{-# INLINE toCounterexample #-}
toCounterexample :: (Seed, (state, space, (dynamic, NonEmpty (Refutation refutation)))) -> Counterexample space dynamic refutation
toCounterexample (seed, (_, space, (dynamic, refutations))) = Counterexample
  { randomSeed = seed
  , searchPoint = space
  , dynamicPart = dynamic
  , refutations = fmap getRefutation refutations
  }

-- | Used to define a property test search.
{-# INLINE searchPredicate #-}
searchPredicate :: forall space dynamic result refutation t .
                   Gen space dynamic
                -> Test dynamic result refutation t
                -> t
                -> (Seed -> space -> Maybe (dynamic, NonEmpty (Refutation refutation)))
-- Want to make this function simplify in a certain way.
--
-- Writing it as an explicit lambda on seed and space seems to help the
-- simplifier to do the right thing and float out as much as possible, in case
-- of tests which do not depend upon the seed or the space or both.
searchPredicate gen test t = \seed -> searchPredicateAt
  (sampleAt_ gen seed)
  (runSubjectAt t (subject test))
  (checkExpectationsAt t (expectations test))

{-# INLINE searchPredicateAt #-}
searchPredicateAt :: (space -> dynamic)
                  -> (dynamic -> result)
                  -> (dynamic -> result -> [Refutation refutation])
                  -> (space -> Maybe (dynamic, NonEmpty (Refutation refutation)))
searchPredicateAt appliedGen appliedSubject appliedVerification = \space ->
  let dynamic = appliedGen space
      result = appliedSubject dynamic
      refutations = appliedVerification dynamic result
   in fmap ((,) dynamic) (nonEmpty refutations)

-- | Defined for use in runConjunction; choice of list is for its semigroup
-- instance.
{-# INLINE CONLIKE checkExpectation #-}
checkExpectation :: t -> dynamic -> result -> Expectation refutation dynamic result t -> [Refutation refutation]
checkExpectation t d r (Expectation _mSrcLoc refutation v) = case runVerification v t d r of
  True -> []
  False -> [refutation]

{-# INLINE CONLIKE checkExpectationsAt #-}
checkExpectationsAt :: static -> Expectations refutation dynamic result static -> dynamic -> result -> [Refutation refutation]
checkExpectationsAt static expectations dynamic result =
  runConjunction (checkExpectation static dynamic result) expectations

{-# INLINE runSubjectAt #-}
runSubjectAt :: static -> Subject dynamic result static -> (dynamic -> result)
runSubjectAt static (Subject k) = k static
