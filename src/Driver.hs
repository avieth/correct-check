module Driver
  ( Counterexample (..)
  , checkSequential
  , checkSequentialAll
  , checkParallel
  , checkParallelAll

  -- * Repl utils
  , quickCheck
  , quickCheckParallel
  , quickCheckAt
  , quickCheckParallelAt
  , QuickCheck (..)
  ) where

import Data.List.NonEmpty (NonEmpty, nonEmpty)
import Data.Text (Text)
import qualified Data.Text as T (unpack)
import Data.Functor ((<&>))
import Property
import Space.Random
import Space.Search
import Types

-- 'quickCheck' is a driver to test an individual pure property and show the
-- result
--
-- TODO
-- - an IO test driver which will show the srcloc of the failing property and
--   parameter and random seed which caused it to fail; better yet, the
--   particular space at which the minimal case was found. If we can show and
--   read and write the space then it's more useful; just reconstruct the
--   space, take the seed at that run, and you're good to go (no need to re
--   run the whole search).

{-# INLINE quickCheck #-}
-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
quickCheck :: Natural -> t -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheck n t prop = newSeedIO <&> quickCheckAt n t prop

{-# INLINE quickCheckParallel #-}
quickCheckParallel :: Natural -> Natural -> t -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheckParallel m n t prop = newSeedIO <&> quickCheckParallelAt m n t prop

{-# INLINE quickCheckAt #-}
quickCheckAt :: Natural
             -> t
             -> Property state space dynamic result refutation t
             -> Seed
             -> QuickCheck space dynamic refutation
quickCheckAt n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkSequential t (randomPoints (n-1) seed) prop else Nothing)

{-# INLINE quickCheckParallelAt #-}
quickCheckParallelAt :: Natural
                     -> Natural
                     -> t
                     -> Property state space dynamic result refutation t
                     -> Seed
                     -> QuickCheck space dynamic refutation
quickCheckParallelAt m n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkParallel m t (randomPoints (n-1) seed) prop else Nothing)

-- | A type for the result of a 'quickCheck', mainly defined for its Show
-- instance.
data QuickCheck space dynamic refutation where
  Passed :: Natural -> Seed -> QuickCheck space dynamic refutation
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space dynamic refutation -> QuickCheck space dynamic refutation

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
instance Show (QuickCheck space dynamic refutation) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  show (Failed _ seed counterexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed, "\n"
    , T.unpack (prettyCounterexample counterexample)
    ]

-- | A counterexample produced by a property test. It gives the random seed and
-- search space, and also the value that was produced by the generator at this
-- point (even though it can be reproduced). It also has the non-empty set of
-- refutations, corresponding to the expectations which failed at this point.
data Counterexample space dynamic refutation = Counterexample
  { randomSeed :: Seed
  , searchPoint :: space
  , dynamicPart :: dynamic
  , refutations :: NonEmpty refutation
  }

-- TODO
instance Show (Counterexample space dynamic refutation) where
  show = const "Counterexample"

-- TODO
prettyCounterexample :: Counterexample space dynamic refutation -> Text
prettyCounterexample _ = mempty

{-# INLINE checkSequentialAll #-}
-- | Check the property at each of these seeds, giving all counterexamples.
checkSequentialAll :: t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkSequentialAll t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequentialAll
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkSequential #-}
-- | Check the property at each of these seeds, stopping at the first
-- counterexample.
checkSequential :: t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkSequential t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequential
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallel #-}
-- | Same as 'checkSequentialAll' but will check a given number in parallel (the
-- Natural number parameter) and every seed will be checked.
checkParallelAll :: Natural -> t -> RandomPoints -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkParallelAll n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallelAll
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkParallelAll #-}
-- | 'checkParallel' but stop at the first counterexample.
checkParallel :: Natural -> t -> RandomPoints -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkParallel n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallel
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

-- | Convert a search result into a counterexample.
{-# INLINE toCounterexample #-}
toCounterexample :: (Seed, (state, space, (dynamic, NonEmpty (Refutation refutation)))) -> Counterexample space dynamic refutation
toCounterexample (seed, (_, space, (dynamic, refutations))) = Counterexample
  { randomSeed = seed
  , searchPoint = space
  , dynamicPart = dynamic
  , refutations = fmap getRefutation refutations
  }

-- | Used to define a property test search.
{-# INLINE searchPredicate #-}
searchPredicate :: forall space dynamic result refutation t .
                   Gen space dynamic
                -> Test dynamic result refutation t
                -> t
                -> (Seed -> space -> Maybe (dynamic, NonEmpty (Refutation refutation)))
searchPredicate gen test t = \seed space -> 
  -- Want to make this function simplify in a certain way.
  --
  -- Writing it as an explicit lambda on seed and space seems to help the
  -- simplifier to do the right thing.
  --
  -- In case GHC can determine that `sampleAt seed space gen = x`, it
  -- ought to be floated out.
  --
  -- After that, `result = runSubject (subject test) t x` could also be
  -- floated out, and so could `refutations`.
  --
  -- If we want a rewrite rule to fire, we'll need GHC to float these out and
  -- put an explicit lambda.
  --
  --   let x = sampleAt seed space gen
  --       result = runSubject (subject test) t dynamic
  --       refutations = runConjunction (checkExpectation t dynamic result) (expectations test)
  --    in \() -> case refutations of
  --         [] -> Nothing
  --         (r:rs) -> Just (x, r :| rs)
  --
  -- Or is there another avenue?
  let dynamic = sampleAt seed space gen
      result = runSubject (subject test) t dynamic
      refutations = runConjunction (checkExpectation t dynamic result) (expectations test)
   in fmap ((,) dynamic) (nonEmpty refutations)

-- | Defined for use in runConjunction; choice of list is for its semigroup
-- instance.
{-# INLINE checkExpectation #-}
checkExpectation :: t -> dynamic -> result -> Expectation refutation dynamic result t -> [Refutation refutation]
checkExpectation t d r (Expectation _mSrcLoc refutation v) = case runVerification v t d r of
  True -> []
  False -> [refutation]
