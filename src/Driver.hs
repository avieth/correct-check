module Driver
  ( Counterexample (..)
  , checkSequential
  , checkSequential_
  , checkParallel
  , searchPredicate

  -- * Repl utils
  , quickCheck
  , quickCheckAt
  , QuickCheck (..)
  ) where

import Data.List.NonEmpty (NonEmpty, nonEmpty)
import Data.Text (Text)
import qualified Data.Text as T (unpack)
import Data.Functor ((<&>))
import Property
import Space.Random
import Space.Search
import Types

-- TODO define
-- - a driver to test an individual pure property and show the result
--
-- - an IO test driver which will show the srcloc of the failing property and
--   parameter and random seed which caused it to fail; better yet, the
--   particular space at which the minimal case was found. Yeah, if we can show
--   and read and write the space then it's more useful; just reconstruct the
--   space, take the seed at that run, and you're good to go (no need to re
--   run the whole search).

{-# INLINE quickCheck #-}
-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
quickCheck :: t -> Natural -> Property state space dynamic result refutation t -> IO (QuickCheck space dynamic refutation)
quickCheck t n prop = newSeedIO <&> \seed -> quickCheckAt seed t n prop

{-# INLINE quickCheckAt #-}
quickCheckAt :: Seed -> t -> Natural -> Property state space dynamic result refutation t -> QuickCheck space dynamic refutation
quickCheckAt seed t n prop = maybe (Passed n seed) (Failed n seed)
  -- If n is 0 then we must not run checkSequential_
  (if n > 0 then checkSequential_ t (splitN (n-1) seed) prop else Nothing)

data QuickCheck space dynamic refutation where
  Passed :: Natural -> Seed -> QuickCheck space dynamic refutation
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space dynamic refutation -> QuickCheck space dynamic refutation

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
instance Show (QuickCheck space dynamic refutation) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  show (Failed _ seed counterexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed, "\n"
    , T.unpack (prettyCounterexample counterexample)
    ]

-- | A counterexample produced by a property test. It gives the random seed and
-- search space, and also the value that was produced by the generator at this
-- point (even though it can be reproduced). It also has the non-empty set of
-- refutations, corresponding to the expectations which failed at this point.
data Counterexample space dynamic refutation = Counterexample
  { randomSeed :: Seed
  , searchPoint :: space
  , dynamicPart :: dynamic
  , refutations :: NonEmpty refutation
  }

-- TODO
prettyCounterexample :: Counterexample space dynamic refutation -> Text
prettyCounterexample _ = mempty

-- | Check the property at each of these seeds, giving all counterexamples.
checkSequential :: t -> NonEmpty Seed -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkSequential t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequential
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

{-# INLINE checkSequential_ #-}
-- | Check the property at each of these seeds, stopping at the first
-- counterexample.
checkSequential_ :: t -> NonEmpty Seed -> Property state space dynamic result refutation t -> Maybe (Counterexample space dynamic refutation)
checkSequential_ t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchSequential_
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      seeds

-- | Same as 'checkSequential' but will check a given number in parallel (the
-- Natural number parameter) and every seed will be checked.
checkParallel :: Natural -> t -> [Seed] -> Property state space dynamic result refutation t -> [Counterexample space dynamic refutation]
checkParallel n t seeds prop = fmap toCounterexample results
  where
    dom = domain prop
    results = searchParallel
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (test prop) t)
      n
      seeds

-- | Convert a search result into a counterexample.
toCounterexample :: (Seed, state, space, (dynamic, NonEmpty (Refutation refutation))) -> Counterexample space dynamic refutation
toCounterexample (seed, _, space, (dynamic, refutations)) = Counterexample
  { randomSeed = seed
  , searchPoint = space
  , dynamicPart = dynamic
  , refutations = fmap getRefutation refutations
  }


{-# INLINE searchPredicate #-}
-- | Used to define a property test search.
searchPredicate :: forall space dynamic result refutation t .
                   Gen space dynamic
                -> Test dynamic result refutation t
                -> t
                -> (Seed -> space -> Maybe (dynamic, NonEmpty (Refutation refutation)))
searchPredicate gen test t = \seed space ->
  let dynamic = sampleAt seed space gen
      result = runSubject (subject test) t dynamic
      refutations :: [Refutation refutation]
      refutations = runConjunction (checkExpectation t dynamic result) (expectations test)
   in (,) dynamic <$> nonEmpty refutations

-- | Defined for use in runConjunction; choice of list is for its semigroup
-- instance.
checkExpectation :: t -> dynamic -> result -> Expectation refutation dynamic result t -> [Refutation refutation]
checkExpectation t d r (Expectation refutation v) = case runVerification v t d r of
  True -> []
  False -> [refutation]
