module Driver
  ( Counterexample (..)
  , checkSequential
  , checkSequentialAll
  , checkParallel
  , checkParallelAll

  -- * Repl utils
  , quickCheck
  , quickCheckParallel
  , quickCheckAt
  , quickCheckParallelAt
  , QuickCheck (..)

  -- * Low-level
  , searchPredicate
  ) where

import Data.List.NonEmpty (NonEmpty, nonEmpty)
import Data.Functor ((<&>))
import Data.Word (Word32)
import Property
import Space.Random
import Space.Search
import Types

-- 'quickCheck' is a driver to test an individual pure property and show the
-- result

-- | Useful for interactive development. Checks the property at a given number
-- of points, giving at most one counterexample.
--
-- It's in IO because it will grab a new random seed from system entropy.
--
-- To re-run a complete 'quickCheck', use 'quickCheckAt'.
{-# INLINE quickCheck #-}
quickCheck :: Natural
           -> t
           -> Property state space dynamic result refutation t
           -> IO (QuickCheck space dynamic result refutation)
quickCheck n t prop = newSeedIO <&> quickCheckAt n t prop

{-# INLINE quickCheckParallel #-}
quickCheckParallel :: Natural
                   -> Natural
                   -> t
                   -> Property state space dynamic result refutation t
                   -> IO (QuickCheck space dynamic result refutation)
quickCheckParallel m n t prop = newSeedIO <&> quickCheckParallelAt m n t prop

{-# INLINE quickCheckAt #-}
quickCheckAt :: Natural
             -> t
             -> Property state space dynamic result refutation t
             -> Seed
             -> QuickCheck space dynamic result refutation
quickCheckAt n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkSequential t (randomPoints (n' - 1) seed) prop else Nothing)
  where
    !n' = clampToWord32 tag n
    tag = "quickCheckSequential"

{-# INLINE quickCheckParallelAt #-}
quickCheckParallelAt :: Natural
                     -> Natural
                     -> t
                     -> Property state space dynamic result refutation t
                     -> Seed
                     -> QuickCheck space dynamic result refutation
quickCheckParallelAt m n t prop seed = maybe (Passed n seed) (Failed n seed)
  -- checkSequential always uses at least one point, so we have to check n here.
  -- randomPoints takes the number of points desired less 1.
  (if n > 0 then checkParallel m' t (randomPoints (n' - 1) seed) prop else Nothing)
  where
    -- Want to crash early so we force these
    !m' = clampToWord32 tag m
    !n' = clampToWord32 tag n
    tag = "quickCheckParallel"

-- | A type for the result of a 'quickCheck', mainly defined for its Show
-- instance.
data QuickCheck space dynamic result refutation where
  Passed :: Natural -> Seed -> QuickCheck space dynamic result refutation
  -- | Includes the initial seed that was generated by 'quickCheck'; the
  -- counterexample will have the seed of the particular test case.
  Failed :: Natural -> Seed -> Counterexample space dynamic result refutation -> QuickCheck space dynamic result refutation

-- | Show instance is defined for the benefit of using 'quickCheck' in the repl.
instance Show (QuickCheck space dynamic result refutation) where
  show (Passed n seed) = mconcat
    [ "Passed "
    , show n
    , " random samples with initial seed "
    , showSeedHex seed
    ]
  -- TODO show more.
  show (Failed _ seed _counterexample) = mconcat
    [ "Found counterexample from initial seed ", showSeedHex seed ]

{-# INLINE checkSequentialAll #-}
-- | Check the property at each of these seeds, giving all counterexamples.
checkSequentialAll :: t
                   -> RandomPoints
                   -> Property state space dynamic result refutation t
                   -> [Counterexample space dynamic result refutation]
checkSequentialAll t seeds prop = fmap toCounterexample results
  where
    dom = propertyDomain prop
    results = searchSequentialAll
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (propertyTest prop) t)
      seeds

{-# INLINE checkSequential #-}
-- | Check the property at each of these seeds, stopping at the first
-- counterexample.
checkSequential :: t
                -> RandomPoints
                -> Property state space dynamic result refutation t
                -> Maybe (Counterexample space dynamic result refutation)
checkSequential t seeds prop = fmap toCounterexample results
  where
    dom = propertyDomain prop
    results = searchSequential
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (propertyTest prop) t)
      seeds

{-# INLINE checkParallel #-}
-- | Same as 'checkSequentialAll' but will check a given number in parallel (the
-- Word32 parameter) and every seed will be checked.
checkParallelAll :: Word32
                 -> t
                 -> RandomPoints
                 -> Property state space dynamic result refutation t
                 -> [Counterexample space dynamic result refutation]
checkParallelAll n t seeds prop = fmap toCounterexample results
  where
    dom = propertyDomain prop
    results = searchParallelAll
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (propertyTest prop) t)
      seeds

{-# INLINE checkParallelAll #-}
-- | 'checkParallel' but stop at the first counterexample.
checkParallel :: Word32
              -> t
              -> RandomPoints
              -> Property state space dynamic result refutation t
              -> Maybe (Counterexample space dynamic result refutation)
checkParallel n t seeds prop = fmap toCounterexample results
  where
    dom = propertyDomain prop
    results = searchParallel
      n
      (strategy (search dom))
      (initialState (search dom))
      (minimalSpace (search dom))
      (searchPredicate (generate dom) (propertyTest prop) t)
      seeds

-- | Convert a search result into a counterexample.
{-# INLINE toCounterexample #-}
toCounterexample :: (Seed, (state, space, (dynamic, result, NonEmpty (Refutation refutation))))
                 -> Counterexample space dynamic result refutation
toCounterexample (seed, (_, space, (dynamic, result, refutations))) = Counterexample
  { randomSeed = seed
  , searchPoint = space
  , dynamicPart = dynamic
  , resultPart = result
  , refutations = refutations
  }

-- | Used to define a property test search.
{-# INLINE searchPredicate #-}
searchPredicate :: forall space dynamic result refutation t .
                   Gen space dynamic
                -> Test dynamic result refutation t
                -> t
                -> (Seed -> space -> Maybe (dynamic, result, NonEmpty (Refutation refutation)))
-- Want to make this function simplify in a certain way.
--
-- Writing it as an explicit lambda on seed and space seems to help the
-- simplifier to do the right thing and float out as much as possible, in case
-- of tests which do not depend upon the seed or the space or both.
searchPredicate gen test t = \seed -> searchPredicateAt
  (sampleAt_ gen seed)
  (runSubjectAt t (subject test))
  (checkExpectationsAt t (expectations test))

{-# INLINE searchPredicateAt #-}
searchPredicateAt :: (space -> dynamic)
                  -> (dynamic -> result)
                  -> (dynamic -> result -> [Refutation refutation])
                  -> (space -> Maybe (dynamic, result, NonEmpty (Refutation refutation)))
searchPredicateAt appliedGen appliedSubject appliedVerification = \space ->
  let dynamic = appliedGen space
      result = appliedSubject dynamic
      refutations = appliedVerification dynamic result
   in fmap (\t -> (dynamic, result, t)) (nonEmpty refutations)

-- | Defined for use in runConjunction; choice of list is for its semigroup
-- instance.
{-# INLINE CONLIKE checkExpectation #-}
checkExpectation :: t -> dynamic -> result -> Expectation refutation dynamic result t -> [Refutation refutation]
checkExpectation t d r (Expectation refutation v) = case runVerification v t d r of
  True -> []
  False -> [refutation]

{-# INLINE CONLIKE checkExpectationsAt #-}
checkExpectationsAt :: static -> Expectations refutation dynamic result static -> dynamic -> result -> [Refutation refutation]
checkExpectationsAt static expectations dynamic result =
  runConjunction (checkExpectation static dynamic result) expectations

{-# INLINE runSubjectAt #-}
runSubjectAt :: static -> Subject dynamic result static -> (dynamic -> result)
runSubjectAt static (Subject k) = k static
